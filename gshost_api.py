"""GSHost Web API Wrapper

Allows remote secure management of a gshost.us server from python

All methods are blocking on a HTTP call to the API, please don't try to use them in realtime loops :)
"""

import requests
from time import sleep

#server management class
class server:

	def __init__(self, node, id_num, auth):
		"""Initialise the server

		Arguments:
		node -- the hostname of the node that the server is run from
		id_num -- the id number of the server
		auth -- the authentication information for the api, a tuple of your gshost login and password
		"""
		self.node = node
		self.id = id_num
		self.auth = auth
		self.name = "{} server {}".format(self.node, self.id)
		self.url_base = 'https://{0}/api/v0/server/{1}/'.format(self.node, self.id)

	def start(self):
		"""Start the server, if it's currently down"""
		r = requests.post(self.url_base + 'start', auth=self.auth)
		r.raise_for_status()

	def stop(self):
		"""Stop the server, if it's currently up"""
		r = requests.post(self.url_base + 'stop', auth=self.auth)
		r.raise_for_status()

	def restart(self):
		"""Force the server to restart"""
		self.stop_server()
		self.start_server()

	def status(self):
		"""Get the server status, as a dictionary"""
		r = requests.get(self.url_base + 'status', auth=self.auth)
		r.raise_for_status()
		return r.json()

	def running(self):
		"""Check if the server is running"""
		return self.status()['running']

	def write_file(self, filename, file_contents):
		"""Write a file to the server"""
		r = requests.put(self.url_base + 'file?path=' + filename, auth=self.auth, data=file_contents)
		r.raise_for_status()

	def write_config_from_dict(self, filename, cfg_dict):
		"""Write out a config file from a dictionary of key -> value (ends up as key = value)

		Values will be coerced to strings.

		Careful: the semantics of this can be a little strange; if you embed newlines in your values
		you can end up with extra keys, and comments will also be entered verbatim.

		You may need to add quotes in some cases.

		The file ends up with \n newlines, and no trailing newline.
		"""
		lines = ["#(autogenerated config)"]
		for key, value in cfg_dict.iteritems():
			line = str(key)
			if value != '':
				line += ' = '+ str(value)
			lines.append(line)

		file_contents = '\n'.join(lines)
		self.write_file(filename, file_contents)

	def write_tcpr(self, tcpr_lines):
		"""Write something to the console of the server

		Useful for injecting scripts or simple /commands from an external service.

		(make sure tcpr is set up in autoconfig - auth is pulled from the config
		so using something like a SHA-256 hash of the time and some salt when
		setting up the server is an ok way to keep things very secure, if you
		dont need anyone to manually enter the rcon pass)
		"""
		r = requests.post(self.url_base + 'rcon', auth=self.auth, data=tcpr_lines)
		r.raise_for_status()

	def write_tcpr_until_succeeds(self, tcpr_lines, wait_time=None, retry_limit=None):
		"""Reliably write something to the console of the server

		This will retry until it succeeds, or until the retry_limit (default 60)
		is hit. If the limit is hit, it'll raise an exception and exit.

		Waits for wait_time (default 1) seconds between retries - does no sleeping
		if the first attempt succeeds.

		Use retry_limit < 0 for no limit.

		Use retry_limit = 0 for no retry (basically ends up as write_tcpr)
		"""
		if wait_time is None:
			wait_time = 1

		if retry_limit is None:
			retry_limit = 60

		success = False
		while not success:
			#otherwise, try writing tcpr
			try:
				self.write_tcpr(tcpr_lines)
				success = True
			except Exception:
				pass

			if not success:
				#sleep allocated time
				sleep(wait_time)
				#tick retry limit
				if retry_limit > 0:
					if retry_limit == 0:
						raise Exception('hit retry limit')
					else:
						retry_limit -= 1
